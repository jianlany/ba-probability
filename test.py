#!/usr/bin/env python3
import unittest
import sys
import numpy
from numpy.linalg import norm
from subprocess import check_call



class Test_ba(unittest.TestCase):

    ba_values = numpy.array([[2.5053, 2.47447, 163.684],
                             [2.4744, 2.47886, 129.934],
                             [2.4788, 2.69089, 134.065]])

    cmd = '{} ba-test-sample.txt --output-file badf-test.txt'\
          ' --num_theta 500 --num_length 300 --d_range 1.5 3.5'\
          ' --theta_range 0.0 180.0 --d_width_factor 3.0 --q_width_factor 5.0'

    ba_exe = './ba-probability'

    @classmethod
    def setUpClass(cls):
        print('Setting up tests...')
        numpy.savetxt('ba-test-sample.txt', cls.ba_values)
        try:
            check_call(cls.cmd.format(cls.ba_exe).split())
        except:
            print("################")
            print("Call ba-probability failed, note that must run test with GPU")
            print("################")
            sys.exit(1)
        cls.badf = cls.read_badf_file('badf-test.txt')
        lmin = 1.5
        lmax = 3.5
        qmin = 0.0
        qmax = 180.0
        wl   = 3.0
        wq   = 5.0
        nl   = 300
        nq   = 500
        l = numpy.concatenate((cls.ba_values[:,0], cls.ba_values[:,1]))
        q = numpy.concatenate((cls.ba_values[:,2], cls.ba_values[:,2]))
        l_grid, q_grid = numpy.meshgrid(numpy.linspace(lmin,lmax,nl),
                                                  numpy.linspace(qmin,qmax,nq))
        dl = (lmax-lmin)/(nl-1)
        dq = (qmax-qmin)/(nq-1)
        cls.p     = numpy.zeros((nq, nl))
        cls.dpdl  = numpy.zeros((nq, nl))
        cls.dpdq  = numpy.zeros((nq, nl))
        cls.dpdlq = numpy.zeros((nq, nl))
        for l_mean, q_mean in zip(l, q):
            cls.p     +=     cls.get_p(l_grid, q_grid, wl*dl, wq*dq, l_mean, q_mean)
            cls.dpdl  +=  cls.get_dpdl(l_grid, q_grid, wl*dl, wq*dq, l_mean, q_mean)
            cls.dpdq  +=  cls.get_dpdq(l_grid, q_grid, wl*dl, wq*dq, l_mean, q_mean)
            cls.dpdlq += cls.get_dpdlq(l_grid, q_grid, wl*dl, wq*dq, l_mean, q_mean)
        cls.p    /= len(l)
        cls.dpdl /= len(l)
        cls.dpdq /= len(l)
        cls.dpdlq/= len(l)
        print("Setup done.")

    def setUp(self):
        pass


    def tearDown(self):
        pass


    def test_p(self):
        '''test the l2 norm error of p is smaller than 1e-5'''
        self.assertTrue(norm(self.badf.p-self.p)/norm(self.p) < 1e-5)


    def test_dpdl(self):
        '''test the l2 norm error of dpdl is smaller than 1e-5'''
        self.assertTrue(norm(self.badf.dpdl-self.dpdl)/norm(self.dpdl) < 1e-5)


    def test_dpdq(self):
        '''test the l2 norm error of dpdq is smaller than 1e-5'''
        self.assertTrue(norm(self.badf.dpdq-self.dpdq)/norm(self.dpdq) < 1e-5)


    def test_dpdlq(self):
        '''test the l2 norm error of dpdlq is smaller than 1e-5'''
        self.assertTrue(norm(self.badf.dpdlq-self.dpdlq)/norm(self.dpdlq) < 1e-5)


    def read_badf_file(path, var = False):
        ''' Reads the probability file generated by ba-probability. '''
        class Data:  pass
        data = Data()
        fid = open(path, 'rb')
        fid.readline()   # tells BA file (skip).
        data.nl, data.nq = [int(s) for s in fid.readline().split()[-2:]]
        data.llo, data.lhi = [float(s) for s in fid.readline().split()[-2:]]
        data.qlo, data.qhi = [float(s) for s in fid.readline().split()[-2:]]
        data.p = numpy.genfromtxt(fid, max_rows=data.nq)
        data.dpdl = numpy.genfromtxt(fid, max_rows=data.nq)
        data.dpdq = numpy.genfromtxt(fid, max_rows=data.nq)
        data.dpdlq = numpy.genfromtxt(fid, max_rows=data.nq)
        if var:
            data.var = numpy.genfromtxt(fid, max_rows = data.nq)
        fid.close()
        if len(data.p) != data.nq or len(data.p[0]) != data.nl or \
           len(data.dpdl) != data.nq or len(data.dpdl[0]) != data.nl or \
           len(data.dpdq) != data.nq or len(data.dpdq[0]) != data.nl or \
           len(data.dpdlq) != data.nq or len(data.dpdlq[0]) != data.nl:
            print("Dimension of the data read does not agree with the header in badf file!\n{}" \
                  .format(path))
            sys.exit(1)
        if var:
            if len(data.var) != data.nq or len(data.var[0]) != data.nl:
                print("Dimension of the data read does not agree with the header in badf file!\n{}" \
                      .format(path))
        return data


    def get_p(l, q, wl, wq, lmean, qmean):
        '''return the pdf of a 2d gaussian distribution'''
        normalizer = (2*numpy.pi*wl*wq)
        return numpy.exp(-0.5*((l-lmean)**2/wl**2 +
                               (q-qmean)**2/wq**2))/normalizer


    def get_dpdl(l, q, wl, wq, lmean, qmean):
        '''return the dpdl of a 2d gaussian distribution function'''
        normalizer = 1.0/(2*numpy.pi*wl*wq)
        deri = -(l - lmean)/wl**2
        return deri*numpy.exp(-0.5*((l-lmean)**2/wl**2 +
                                    (q-qmean)**2/wq**2))*normalizer


    def get_dpdq(l, q, wl, wq, lmean, qmean):
        '''return the dpdq of a 2d gaussian distribution function'''
        normalizer = 1.0/(2*numpy.pi*wl*wq)
        deri = -(q - qmean)/wq**2
        return deri*numpy.exp(-0.5*((l-lmean)**2/wl**2 +
                                    (q-qmean)**2/wq**2))*normalizer


    def get_dpdlq(l, q, wl, wq, lmean, qmean):
        '''return the dpdlq of a 2d gaussian distribution function'''
        normalizer = 1.0/(2*numpy.pi*wl*wq)
        deri = (l - lmean)*(q - qmean)/(wq**2*wl**2)
        return deri*numpy.exp(-0.5*((l-lmean)**2/wl**2 +
                                    (q-qmean)**2/wq**2))*normalizer


if __name__ == "__main__":
    unittest.main()
