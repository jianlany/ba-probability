#!/usr/bin/env python3
import numpy
from matplotlib import pyplot
from mpl_toolkits.mplot3d import Axes3D
pyplot.rc('font', size=8)
pyplot.rc('mathtext', fontset='cm')
pyplot.rc('text', usetex=True)

kB = 0.001987204118

def read_probability_file(path):
    ''' Reads the probability file generated by ba-probability. '''
    class Data:  pass
    data = Data()
    fid = open(path, 'rb')
    fid.readline()   # tells BA file (skip).
    data.M, data.N = [int(s) for s in fid.readline().split()[-2:]]
    data.xlo, data.xhi = [float(s) for s in fid.readline().split()[-2:]]
    data.ylo, data.yhi = [float(s) for s in fid.readline().split()[-2:]]
    fid.readline()  # should be p 
    
    data.p = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdl
    data.dpdl = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdq
    data.dpdq = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdql
    data.dpdql = numpy.genfromtxt(fid, max_rows=data.N)
    return data


def compute_initial_energy(data, T=300.0):
    ''' Computes the initial guess for the bond-angle energy from a probability
    distribution file. '''
    U = -kB * T * numpy.log(data.p)
    Ul = -kB * T * data.dpdl / data.p
    Uq = -kB * T * data.dpdq / data.p
    Ulq = -kB * T * (data.dpdql / data.p - data.dpdl*data.dpdq / (data.p*data.p))
    write_potential('angle.table.EEE', data, U, Ul, Uq, Ulq)

    x = numpy.linspace(data.xlo, data.xhi, data.M)
    y = numpy.linspace(data.ylo, data.yhi, data.N)
    x,y = numpy.meshgrid(x,y)
    fig = pyplot.figure(figsize=(5,3))
    ax = pyplot.subplot(111)

    class nf(float):
        def __repr__(self):
            s = f'{self:.1f}'
            return f'{self:.0f}' if s[-1] == '0' else s
    vv = numpy.arange(0.6, 10.5, 0.2)
    cs = ax.contour(y,0.1*x,U, vv, cmap='viridis', 
                    linewidths=1.0)
    cs.levels = [nf(val) for val in cs.levels]
    ax.clabel(cs, cs.levels[:15], inline=True, fmt='%.1f', fontsize=5, inline_spacing=0)

    ax.set_xlim(90, 180)
    ax.set_ylim(0.22, 0.27)
    ax.set_xlabel(r'$\theta$ (rad)')
    ax.set_ylabel(r'$l$ (nm)')
    ax.set_xticks([90, 120, 150, 180])
    ax.set_xticklabels([r'$\frac{1}{2}\pi$', r'$\frac{2}{3}\pi$',    
                        r'$\frac{5}{6}\pi$', r'$\pi$'])

    pyplot.tight_layout()
    pyplot.savefig('U.png', dpi=300)

    dx = (data.xhi - data.xlo) / (data.M - 1)
    dy = (data.yhi - data.ylo) / (data.N - 1)
    verify_derivatives(U, Ul, Uq, Ulq, dx, dy, 'energy-derivatives.png')


def write_potential(path, data, U, Ul, Uq, Ulq):
    ''' Writes a bond-energy LAMMPS potential file.  The file format should be:
    [keyword]
    NL NQ [# l pts] [# q pts]
    (blank line)
    [i] [l] [q] [U] [Ul] [Uq] [Ulq] '''
    with open(path, 'w') as fid:
        fid.write('EEE\n')  # write keyword.
        fid.write('NL NQ {} {}\n\n'.format(data.M, data.N))
        ll = numpy.linspace(data.xlo, data.xhi, data.M)
        qq = numpy.linspace(data.ylo, data.yhi, data.N)
        for i in range(data.N):
            for j in range(data.M):
                I = j + i*data.M
                fid.write('{} {:.4f} {:.2f} {:.6f} {:.6f} {:.6f} {:.6f}\n'.format(
                    I, ll[j], qq[i], U[j,i], Ul[j,i], Uq[j,i], Ulq[j,i]))


def verify_derivatives(f, dfdx, dfdy, df2dxy, dx, dy, plot=None):
    norm = numpy.linalg.norm
     # Test that dpdl is accurate.
    fx = (f[:,2:] - f[:,:-2]) / (2.0*dx)
    e1 = norm(fx - dfdx[:,1:-1]) / norm(dfdx[:,1:-1])
    print('dfdx error norm: {:.5f}'.format(e1))

    fy = (f[2:,:] - f[:-2,:]) / (2.0*dy)
    e2 = norm(fy - dfdy[1:-1,:]) / norm(dfdy[1:-1,:])
    print('dfdy error norm: {:.5f}'.format(e2))

    fxy = (fy[:,2:] - fy[:,:-2]) / (2.0*dx)
    e3 = norm(fxy - df2dxy[1:-1,1:-1]) / norm(df2dxy[1:-1,1:-1])
    print('d2xdxdy error norm: {:.5f}'.format(e3))

    if plot is not None:
        pyplot.figure(figsize=(6,4))
        vv = numpy.linspace(-1, 1, 40)
        pp = dict(linewidths = 0.4)
        s = fx.max() * 0.1
        ax = pyplot.subplot(231)
        ax.contour(fx.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(234)
        ax.contour(dfdx[:,1:-1].T, s*vv, vmin=-s, vmax=s, **pp)

        ax = pyplot.subplot(232)
        s = fy.max() * 0.1
        ax.contour(fy.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(235)
        ax.contour(dfdy[1:-1,:].T, s*vv, vmin=-s, vmax=s, **pp)

        ax = pyplot.subplot(233)
        s = fxy.max() * 0.1
        ax.contour(fxy.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(236)
        ax.contour(df2dxy[1:-1,1:-1:].T, s*vv, vmin=-s, vmax=s, **pp)

        pyplot.tight_layout()
        pyplot.savefig(plot, dpi=300)


if __name__ == '__main__':
    data = read_probability_file('p.txt')
    compute_initial_energy(data)

