#!/usr/bin/env python3
import numpy
from matplotlib import pyplot
from mpl_toolkits.mplot3d import Axes3D
pyplot.rc('font', size=8)
pyplot.rc('mathtext', fontset='cm')


kB = 0.001987204118

def read_probability_file(path):
    ''' Reads the probability file generated by ba-probability. '''
    class Data:  pass
    data = Data()
    fid = open(path, 'rb')
    fid.readline()   # tells BA file (skip).
    data.M, data.N = [int(s) for s in fid.readline().split()[-2:]]
    data.xlo, data.xhi = [float(s) for s in fid.readline().split()[-2:]]
    data.ylo, data.yhi = [float(s) for s in fid.readline().split()[-2:]]
    fid.readline()  # should be p 
    
    data.p = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdl
    data.dpdl = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdq
    data.dpdq = numpy.genfromtxt(fid, max_rows=data.N)
    fid.readline()  # should be dpdql
    data.dpdql = numpy.genfromtxt(fid, max_rows=data.N)
    return data


def compute_initial_energy(data, T=300.0):
    ''' Computes the initial guess for the bond-angle energy from a probability
    distribution file. '''
    U = -kB * T * numpy.log(data.p)
    Ul = -kB * T * data.dpdl / data.p
    Uq = -kB * T * data.dpdq / data.p
    Ulq = -kB * T * (data.dpdql / data.p - data.dpdl*data.dpdq / (data.p*data.p))
    write_potential('angle.table.EEE', data, U, Ul, Uq, Ulq)

    x = numpy.linspace(data.xlo, data.xhi, data.M)
    y = numpy.linspace(data.ylo, data.yhi, data.N)
    x,y = numpy.meshgrid(x,y)
    fig = pyplot.figure(figsize=(3,3))
    ax = fig.gca(projection = '3d')
    ax.plot_surface(x,y,U, Linewidth=0)
    pyplot.tight_layout()
    pyplot.savefig('U.png', dpi=300)

    dx = (data.xhi - data.xlo) / (data.M - 1)
    dy = (data.yhi - data.ylo) / (data.N - 1)
    verify_derivatives(U, Ul, Uq, Ulq, dx, dy, 'energy-derivatives.png')


def write_potential(path, data, U, Ul, Uq, Ulq):
    ''' Writes a bond-energy LAMMPS potential file.  The file format should be:
    [keyword]
    N [# q pts] [# l pts]
    (blank line)
    [i] [l] [q] [U] [Ul] [Uq] [Ulq] '''
    with open(path, 'w') as fid:
        fid.write('EEE\n')  # write keyword.
        fid.write('N {} {}\n\n'.format(data.N, data.M))
        ll = numpy.linspace(data.xlo, data.xhi, data.M)
        qq = numpy.linspace(data.ylo, data.yhi, data.N)
        for i in range(data.N):
            for j in range(data.M):
                I = j + i*data.M
                fid.write('{} {:.4f} {:.2f} {:.6f} {:.6f} {:.6f} {:.6f}\n'.format(
                    I, ll[j], qq[i], U[j,i], Ul[j,i], Uq[j,i], Ulq[j,i]))


def verify_derivatives(f, dfdx, dfdy, df2dxy, dx, dy, plot=None):
    norm = numpy.linalg.norm
     # Test that dpdl is accurate.
    fx = (f[:,2:] - f[:,:-2]) / (2.0*dx)
    e1 = norm(fx - dfdx[:,1:-1]) / norm(dfdx[:,1:-1])
    print('dfdx error norm: {:.5f}'.format(e1))

    fy = (f[2:,:] - f[:-2,:]) / (2.0*dy)
    e2 = norm(fy - dfdy[1:-1,:]) / norm(dfdy[1:-1,:])
    print('dfdy error norm: {:.5f}'.format(e2))

    fxy = (fy[:,2:] - fy[:,:-2]) / (2.0*dx)
    e3 = norm(fxy - df2dxy[1:-1,1:-1]) / norm(df2dxy[1:-1,1:-1])
    print('d2xdxdy error norm: {:.5f}'.format(e3))

    if plot is not None:
        pyplot.figure(figsize=(6,4))
        vv = numpy.linspace(-1, 1, 40)
        pp = dict(linewidths = 0.4)
        s = fx.max() * 0.1
        ax = pyplot.subplot(231)
        ax.contour(fx.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(234)
        ax.contour(dfdx[:,1:-1].T, s*vv, vmin=-s, vmax=s, **pp)

        ax = pyplot.subplot(232)
        s = fy.max() * 0.1
        ax.contour(fy.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(235)
        ax.contour(dfdy[1:-1,:].T, s*vv, vmin=-s, vmax=s, **pp)

        ax = pyplot.subplot(233)
        s = fxy.max() * 0.1
        ax.contour(fxy.T, s*vv, vmin=-s, vmax=s, **pp)
        ax = pyplot.subplot(236)
        ax.contour(df2dxy[1:-1,1:-1:].T, s*vv, vmin=-s, vmax=s, **pp)

        pyplot.tight_layout()
        pyplot.savefig(plot, dpi=300)


if __name__ == '__main__':
    data = read_probability_file('p.txt')
    compute_initial_energy(data)

